defmodule GoParser.Parser do
  @moduledoc """
  
  Documentation for GoParser, Sgf parser tool
  
  Parse sgf file into tokens, then into Tree/Node data structures.
  
  Can be used with elixir_go to parse file into Go.Board.
  
  Avril 2017, hf
  """
  
  alias GoParser.Tree
  require Logger
  
  @doc ~S"""
  Returns a new Tree structure from sgf file.
  """  
  def parse(filename) do
    get_tree(filename)
  end
  
  def get_tree(filename), do: get_tokens(filename) |> parse_tokens
  
  
  @doc ~S"""
  Returns tokens from sgf file.
  Only useful to see the tokens generated by the lexer.
  Note : Don't forget String.to_charlist for Erlang Lexer.
  """   
  def get_tokens(filename) do
    case (File.read(filename)) do
      {:ok, file} ->
        {:ok, tokens, _end_line} = :sgf_lexer.string file |> String.to_charlist
        tokens
      {:error, _} ->
        Logger.debug("could not open file #{filename}")
        []
    end
  end
  
  # PRIVATE
  defp parse_tokens(tokens) do
    # Initial processing state
    state = %{
      tree: Tree.new,
      stack:  [],
      current_node: nil,
      current_prop: nil
    }
    process_tokens(tokens, state)
  end
  
  # Recursive call returning a list of nodes
  defp process_tokens([], %{tree: tree} = _state), do: tree
  defp process_tokens([token | rest], state) do
    new_state = parse_token(token, state)
    process_tokens(rest, new_state)
  end
  
  # Parse token
  defp parse_token({:"(", _}, %{current_node: current_node, stack: stack} = state) do
    # Stack is pushed from start!
    %{state | stack: [current_node | stack]}
  end
  defp parse_token({:")", _}, %{stack: stack} = state) do
    # Pop from start, because stack is reversed!
    {new_current_node, new_stack} = List.pop_at(stack, 0)    
    %{state | current_node: new_current_node, stack: new_stack}
  end
  defp parse_token({:";", _}, %{current_node: current_node, tree: tree} = state) do
    case current_node do
      nil ->
        {:ok, new_current_node, tree} = Tree.add_node tree
        
        %{state | current_node: new_current_node, tree: tree}
      _ ->
        {:ok, new_current_node, tree} = Tree.add_child_node tree, current_node
        
        %{state | current_node: new_current_node, tree: tree}
    end
  end
  defp parse_token({:propident, _, value}, state), do: %{state | current_prop: value}
  defp parse_token({:propvalue, _, value}, %{current_node: current_node, current_prop: current_prop, tree: tree} = state) do
    {:ok, tree} = Tree.add_property(tree, current_node, current_prop, value)
    %{state | tree: tree}
  end
  defp parse_token({_, _}, state), do: state
  defp parse_token({_, _, _}, state), do: state
end